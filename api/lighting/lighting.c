#include "lighting.h"
#include "hallscan_config.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"

// include PIO program header generated by pico SDK for ws2812
#include "ws2812.pio.h"

static PIO pio = pio0;
static uint sm = 0;
// brightness scale in range [0.0 .. 1.0]
static float g_brightness_scale = 1.0f;

// Effect state
static led_effect_t current_effect = LED_EFFECT_STATIC;
static uint8_t effect_speed = 128;
static uint8_t effect_direction = 0;
static uint8_t color1_r = 255, color1_g = 0, color1_b = 0;
static uint8_t color2_r = 0, color2_g = 0, color2_b = 255;
static uint32_t effect_phase = 0;
static uint32_t last_update_ms = 0;

// LED buffer - stores colors at PHYSICAL strip indices (like Shego)
static uint8_t led_buffer[LED_COUNT * 3];

// SignalRGB streaming buffer (full frame); applied per zone based on mask
static uint8_t signalrgb_buffer[LED_COUNT * 3];
static bool signalrgb_valid = false;
// bit0=main keys, bit1=ambient strip, bit2=status (unused on Mina/Taki)
static uint8_t streaming_zones_mask = 0;

// Gradient colors (up to 8 stops)
static uint8_t gradient_colors[8 * 3];
static uint8_t gradient_num_colors = 2;
static uint8_t gradient_orientation = 0;  // 0=horizontal, 1=vertical, 2=diag TL-BR, 3=diag TR-BL
static uint16_t gradient_rotation_deg = 0;

// Static LED buffer - stores host-sent per-LED colors for Static mode
static uint8_t static_led_buffer[LED_COUNT * 3];

// Paint overlay buffer - stores individually painted LEDs (highest priority layer)
// Non-black values here override any effect including Static
static uint8_t paint_overlay_buffer[LED_COUNT * 3];

// Reactive keypress tracking
static uint8_t reactive_keys[SENSOR_COUNT];
static uint32_t reactive_decay = 0;

// Layer indicator state
static uint8_t layer_colors[4][3] = {
    {0, 0, 0},       // Layer 0 - unused (base layer)
    {0, 255, 200},    // Layer 1 - default cyan/mint
    {174, 0, 255},    // Layer 2 - default purple
    {255, 175, 0}     // Layer 3 - default amber
};
static uint8_t current_layer_for_indicator = 0;
static bool layer_indicator_forced = false;

// Caps lock indicator state
static bool caps_overlay_enabled = false;
static bool caps_overlay_active = false;
static uint8_t caps_color_r = 255, caps_color_g = 255, caps_color_b = 255;  // White default

// SOCD toggle ambient animation state
static bool socd_anim_active = false;
static bool socd_anim_green = true;    // true = enable (green), false = disable (red)
static uint8_t socd_anim_step = 0;     // 0..AMBIENT_LED_COUNT/2 (center-out steps)
static uint32_t socd_anim_last_ms = 0;
static uint8_t socd_anim_fade = 255;   // fade-out counter (255..0)

// helper to write a 24-bit GRB pixel into PIO FIFO (pio program expects 24-bit data left-aligned)
static inline void ws2812_put_pixel(PIO pio_inst, uint sm_idx, uint32_t grb) {
    pio_sm_put_blocking(pio_inst, sm_idx, grb << 8u);
}

// Apply brightness and send pixel
static inline void send_pixel(uint8_t r, uint8_t g, uint8_t b) {
    uint8_t r2 = (uint8_t)((float)r * g_brightness_scale);
    uint8_t g2 = (uint8_t)((float)g * g_brightness_scale);
    uint8_t b2 = (uint8_t)((float)b * g_brightness_scale);
    uint32_t grb = ((uint32_t)g2 << 16) | ((uint32_t)r2 << 8) | (uint32_t)b2;
    ws2812_put_pixel(pio, sm, grb);
}

// ========================================
// Helper functions to write to LED buffer by logical index (like Shego)
// These map logical indices to physical strip positions
// ========================================

// Set a key LED by logical key index (0..KEY_LED_COUNT-1)
static inline void set_key_logical_rgb(int logical, uint8_t r, uint8_t g, uint8_t b) {
    if (logical < 0 || logical >= KEY_LED_COUNT) return;
    uint8_t physical = led_position_map[logical];
    if (physical >= LED_COUNT) return;
    led_buffer[physical * 3 + 0] = r;
    led_buffer[physical * 3 + 1] = g;
    led_buffer[physical * 3 + 2] = b;
}

// Set an ambient LED by logical index (0..AMBIENT_LED_COUNT-1)
static inline void set_ambient_idx_rgb(int idx, uint8_t r, uint8_t g, uint8_t b) {
#if AMBIENT_LED_COUNT > 0
    if (idx < 0 || idx >= AMBIENT_LED_COUNT) return;
    uint8_t physical = ambient_led_map[idx];
    if (physical >= LED_COUNT) return;
    led_buffer[physical * 3 + 0] = r;
    led_buffer[physical * 3 + 1] = g;
    led_buffer[physical * 3 + 2] = b;
#else
    (void)idx; (void)r; (void)g; (void)b;
#endif
}

// Clamp float to 0..1 range
static inline float clamp01f(float x) {
    if (x < 0.0f) return 0.0f;
    if (x > 1.0f) return 1.0f;
    return x;
}

// Get X,Y position for a logical key index (for 2D effects like radial/gradient)
static void mina_taki_logical_xy(int logical, float *x_out, float *y_out) {
    // Mina/Taki key rows: 14, 15, 14, 14, 9/11 (Mina has 66, Taki has 68)
    static const int row_lens[5] = {14, 15, 14, 14, KEY_LED_COUNT - 57};  // Last row varies
    const int rows = 5;
    int idx = logical;
    int row = 0;
    while (row < rows && idx >= row_lens[row]) {
        idx -= row_lens[row];
        row++;
    }
    if (row >= rows) {
        row = rows - 1;
        idx = row_lens[row] - 1;
    }

    // IMPORTANT (Mina/Taki): firmware logical key indices follow a serpentine
    // order on some rows (Row 1 and Row 3). When we generate 2D effects (wave,
    // gradient, radial, rainbow), we want X to reflect the *keyboard layout*
    // left->right, not the serpentine index order.
    //
    // This keeps on-device effects visually consistent with the UI/key layout
    // while still using led_position_map for logical->physical LED mapping.
    if (row == 1 || row == 3) {
        idx = (row_lens[row] - 1) - idx;
    }

    float x = (row_lens[row] <= 1) ? 0.5f : ((float)idx / (float)(row_lens[row] - 1));
    float y = (rows <= 1) ? 0.5f : ((float)row / (float)(rows - 1));
    
    *x_out = clamp01f(x);
    *y_out = clamp01f(y);
}

// Calculate gradient position based on orientation and rotation (like Shego)
static float gradient_base_t(float x, float y) {
    // If rotation is set, use rotated projection
    if (gradient_rotation_deg != 0) {
        float rot = ((float)gradient_rotation_deg * 3.14159265f) / 180.0f;
        float cx = x - 0.5f;
        float cy = y - 0.5f;
        float rot_x = cx * cosf(rot) - cy * sinf(rot);
        return clamp01f(rot_x + 0.5f);
    }

    // Otherwise use discrete orientation
    switch (gradient_orientation) {
        case 0: return clamp01f(x);                    // Horizontal (L->R)
        case 1: return clamp01f(y);                    // Vertical (T->B)
        case 2: return clamp01f((x + y) * 0.5f);       // Diagonal TL->BR
        case 3: return clamp01f((y + (1.0f - x)) * 0.5f); // Diagonal TR->BL
        default: return clamp01f(x);                   // Default horizontal
    }
}

// Output all LEDs to the WS2812 strip (in physical order)
static void output_leds(void) {
    // Apply paint overlay - any non-black LED in paint_overlay_buffer overrides the effect
    // This allows paint mode to work on top of any effect, persisting across effect changes
    // We read from logical positions and apply to physical positions
    for (int logical = 0; logical < KEY_LED_COUNT; logical++) {
        uint8_t r = paint_overlay_buffer[logical * 3 + 0];
        uint8_t g = paint_overlay_buffer[logical * 3 + 1];
        uint8_t b = paint_overlay_buffer[logical * 3 + 2];
        if (r != 0 || g != 0 || b != 0) {
            uint8_t physical = led_position_map[logical];
            if (physical < LED_COUNT) {
                led_buffer[physical * 3 + 0] = r;
                led_buffer[physical * 3 + 1] = g;
                led_buffer[physical * 3 + 2] = b;
            }
        }
    }
#if AMBIENT_LED_COUNT > 0
    for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
        int logical = KEY_LED_COUNT + i;
        uint8_t r = paint_overlay_buffer[logical * 3 + 0];
        uint8_t g = paint_overlay_buffer[logical * 3 + 1];
        uint8_t b = paint_overlay_buffer[logical * 3 + 2];
        if (r != 0 || g != 0 || b != 0) {
            uint8_t physical = ambient_led_map[i];
            if (physical < LED_COUNT) {
                led_buffer[physical * 3 + 0] = r;
                led_buffer[physical * 3 + 1] = g;
                led_buffer[physical * 3 + 2] = b;
            }
        }
    }
#endif

    // Apply layer indicator overlay on ambient strip (Mina) when on non-base layer
#if AMBIENT_LED_COUNT > 0
    if (layer_indicator_forced && current_layer_for_indicator > 0 && current_layer_for_indicator < 4) {
        uint8_t lr = layer_colors[current_layer_for_indicator][0];
        uint8_t lg = layer_colors[current_layer_for_indicator][1];
        uint8_t lb = layer_colors[current_layer_for_indicator][2];
        if (lr > 0 || lg > 0 || lb > 0) {
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                set_ambient_idx_rgb(i, lr, lg, lb);
            }
        }
    }
#endif

    // Apply caps lock overlay if enabled and active (on top of paint)
    if (caps_overlay_enabled && caps_overlay_active) {
#ifdef CAPS_LOCK_LED_INDEX
#if HAS_AMBIENT_CAPS_INDICATOR && AMBIENT_LED_COUNT > 0
        // Mina: highlight ambient strip when caps lock is on
        for (int i = 0; i < AMBIENT_LED_COUNT && i < AMBIENT_CAPS_INDICATOR_COUNT; i++) {
            set_ambient_idx_rgb(i, caps_color_r, caps_color_g, caps_color_b);
        }
#else
        // Taki: highlight only the caps lock key LED
        uint8_t caps_physical = led_position_map[CAPS_LOCK_LED_INDEX];
        if (caps_physical < LED_COUNT) {
            led_buffer[caps_physical * 3 + 0] = caps_color_r;
            led_buffer[caps_physical * 3 + 1] = caps_color_g;
            led_buffer[caps_physical * 3 + 2] = caps_color_b;
        }
#endif
#endif
    }
    
    // SOCD toggle animation overlay â€” highest priority on ambient strip
#if AMBIENT_LED_COUNT > 0
    if (socd_anim_active) {
        uint32_t now_ms = to_ms_since_boot(get_absolute_time());
        uint8_t half = AMBIENT_LED_COUNT / 2;  // center split (4 for 8 LEDs)
        uint8_t cr = socd_anim_green ? 0 : 255;
        uint8_t cg = socd_anim_green ? 255 : 0;

        if (socd_anim_step < half) {
            // Propagation phase: 80ms per step, light 2 LEDs at a time from center
            if (now_ms - socd_anim_last_ms >= 80) {
                socd_anim_step++;
                socd_anim_last_ms = now_ms;
            }
            // Black out ambient first, then light up the reached LEDs
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                set_ambient_idx_rgb(i, 0, 0, 0);
            }
            for (uint8_t s = 0; s < socd_anim_step; s++) {
                int left = (half - 1) - s;
                int right = half + s;
                if (left >= 0) set_ambient_idx_rgb(left, cr, cg, 0);
                if (right < AMBIENT_LED_COUNT) set_ambient_idx_rgb(right, cr, cg, 0);
            }
        } else if (socd_anim_fade > 0) {
            // Fade phase: decrement brightness
            if (now_ms - socd_anim_last_ms >= 8) {
                socd_anim_fade = (socd_anim_fade > 12) ? socd_anim_fade - 12 : 0;
                socd_anim_last_ms = now_ms;
            }
            uint8_t fr = (uint8_t)((uint16_t)cr * socd_anim_fade / 255);
            uint8_t fg = (uint8_t)((uint16_t)cg * socd_anim_fade / 255);
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                set_ambient_idx_rgb(i, fr, fg, 0);
            }
        } else {
            // Animation complete
            socd_anim_active = false;
        }
    }
#endif

    // Output in physical strip order.
    // Some PCBs route WS2812 data into the *opposite* end of the LED chain.
    // In that case, the entire strip index ordering is reversed relative to
    // the mapping tables, and effects can appear mirrored/inverted per row.
    //
    // To fix that without changing led_position_map/ambient_led_map, boards
    // can define LED_STRIP_REVERSED=1 in their config.h.
#if defined(LED_STRIP_REVERSED) && (LED_STRIP_REVERSED)
    for (int i = LED_COUNT - 1; i >= 0; i--) {
        send_pixel(led_buffer[i * 3 + 0],
                   led_buffer[i * 3 + 1],
                   led_buffer[i * 3 + 2]);
    }
#else
    for (int i = 0; i < LED_COUNT; i++) {
        send_pixel(led_buffer[i * 3 + 0],
                   led_buffer[i * 3 + 1],
                   led_buffer[i * 3 + 2]);
    }
#endif
}

void lighting_init(void)
{
    // add program and init state machine
    sm = pio_claim_unused_sm(pio, true);
    uint offset = pio_add_program(pio, &ws2812_program);
    // initialize with 800kHz freq, uses function from generated header
    ws2812_program_init(pio, sm, offset, LED_PIN, 800000, false);
    
    // Initialize LED buffers to off
    memset(led_buffer, 0, sizeof(led_buffer));
    memset(static_led_buffer, 0, sizeof(static_led_buffer));
    memset(paint_overlay_buffer, 0, sizeof(paint_overlay_buffer));
    
    // Set default gradient (red -> blue)
    gradient_colors[0] = 255; gradient_colors[1] = 0; gradient_colors[2] = 0;
    gradient_colors[3] = 0; gradient_colors[4] = 0; gradient_colors[5] = 255;
    gradient_num_colors = 2;
    
    // Clear reactive keys
    memset(reactive_keys, 0, sizeof(reactive_keys));
}

// convenience: convert 8-bit r,g,b to 24-bit GRB value and send
void lighting_set_pixel_rgb(int idx, uint8_t r, uint8_t g, uint8_t b)
{
    (void) idx; // ws2812 pio program writes directly to the stream; we don't use index for addressing
    send_pixel(r, g, b);
}

void lighting_set_all_rgb(uint8_t r, uint8_t g, uint8_t b)
{
    for (int i = 0; i < LED_COUNT; ++i) {
        send_pixel(r, g, b);
    }
}

void lighting_set_max_brightness_percent(uint8_t percent)
{
    if (percent == 0) {
        g_brightness_scale = 0.0f;
    } else if (percent >= 100) {
        g_brightness_scale = 1.0f;
    } else {
        g_brightness_scale = (float)percent / 100.0f;
    }
}

void lighting_set_effect(led_effect_t effect)
{
    current_effect = effect;
    effect_phase = 0;
    printf("Effect set to %d\n", effect);
}

void lighting_set_effect_speed(uint8_t speed)
{
    effect_speed = speed;
}

void lighting_set_effect_direction(uint8_t direction)
{
    effect_direction = direction;
}

void lighting_set_effect_color1(uint8_t r, uint8_t g, uint8_t b)
{
    color1_r = r; color1_g = g; color1_b = b;
}

void lighting_set_effect_color2(uint8_t r, uint8_t g, uint8_t b)
{
    color2_r = r; color2_g = g; color2_b = b;
}

void lighting_set_gradient(uint8_t num_colors, const uint8_t *colors)
{
    if (num_colors > 8) num_colors = 8;
    if (num_colors < 1) num_colors = 1;
    gradient_num_colors = num_colors;
    memcpy(gradient_colors, colors, num_colors * 3);
}

void lighting_set_gradient_params(uint8_t orientation, uint16_t rotation_deg)
{
    if (orientation > 3) orientation = 0;  // Default to horizontal
    if (rotation_deg > 360) rotation_deg = (uint16_t)(rotation_deg % 360);
    gradient_orientation = orientation;
    gradient_rotation_deg = rotation_deg;
}

void lighting_get_gradient(uint8_t *num_colors_out, uint8_t *colors_out, uint16_t colors_out_len)
{
    if (num_colors_out) {
        *num_colors_out = gradient_num_colors;
    }
    if (!colors_out || colors_out_len == 0) return;
    uint16_t n = colors_out_len;
    uint16_t max = (uint16_t)sizeof(gradient_colors);
    if (n > max) n = max;
    memcpy(colors_out, gradient_colors, n);
}

void lighting_get_gradient_params(uint8_t *orientation_out, uint16_t *rotation_deg_out)
{
    if (orientation_out) *orientation_out = gradient_orientation;
    if (rotation_deg_out) *rotation_deg_out = gradient_rotation_deg;
}

void lighting_set_led_buffer(const uint8_t *buffer, uint16_t len)
{
    // Host sends colors in logical order (key 0, key 1, ..., ambient 0, ...)
    // Store in static_led_buffer for Static mode
    // DO NOT copy to led_buffer directly - effects render to led_buffer,
    // and output_leds() applies the paint overlay from paint_overlay_buffer
    if (len > sizeof(static_led_buffer)) len = sizeof(static_led_buffer);
    memcpy(static_led_buffer, buffer, len);
}

void lighting_set_paint_led(uint8_t led_index, uint8_t r, uint8_t g, uint8_t b)
{
    // Set a single LED in the paint overlay buffer (logical index)
    // This is the highest priority layer - overrides any effect
    if (led_index >= LED_COUNT) return;
    paint_overlay_buffer[led_index * 3 + 0] = r;
    paint_overlay_buffer[led_index * 3 + 1] = g;
    paint_overlay_buffer[led_index * 3 + 2] = b;
}

void lighting_clear_paint_overlay(void)
{
    // Clear all painted LEDs - returns to base effect
    memset(paint_overlay_buffer, 0, sizeof(paint_overlay_buffer));
}

void lighting_set_streaming_zones(uint8_t zone_mask)
{
    // Two-zone hardware: accept only main + ambient bits.
    streaming_zones_mask = zone_mask & 0x03;
}

uint8_t lighting_get_streaming_zones(void)
{
    return streaming_zones_mask & 0x03;
}

void lighting_set_signalrgb_buffer(const uint8_t *buffer, uint16_t len)
{
    if (!buffer || len == 0) return;
    if (len > sizeof(signalrgb_buffer)) len = sizeof(signalrgb_buffer);
    memcpy(signalrgb_buffer, buffer, len);
    // If host sends partial, keep rest as-is; still consider it valid.
    signalrgb_valid = true;
}

void lighting_notify_keypress(uint8_t key_idx)
{
    if (key_idx < SENSOR_COUNT) {
        reactive_keys[key_idx] = 255;  // Full brightness on press
    }
}

// Interpolate between two colors
static void lerp_color(uint8_t r1, uint8_t g1, uint8_t b1,
                       uint8_t r2, uint8_t g2, uint8_t b2,
                       uint8_t t, uint8_t *r, uint8_t *g, uint8_t *b)
{
    *r = r1 + ((r2 - r1) * t) / 255;
    *g = g1 + ((g2 - g1) * t) / 255;
    *b = b1 + ((b2 - b1) * t) / 255;
}

// Wrap float to 0-1 range (for seamless looping effects)
static inline float wrap01f(float x) {
    x = fmodf(x, 1.0f);
    if (x < 0.0f) x += 1.0f;
    return x;
}

// Sample gradient palette cyclically (wraps around for seamless animation)
static void gradient_sample_cyclic_palette(float t, const uint8_t *palette_colors, uint8_t palette_num_colors,
                                          uint8_t *r, uint8_t *g, uint8_t *b) {
    if (palette_num_colors == 0 || !palette_colors) {
        *r = *g = *b = 0;
        return;
    }
    if (palette_num_colors == 1) {
        *r = palette_colors[0];
        *g = palette_colors[1];
        *b = palette_colors[2];
        return;
    }

    t = wrap01f(t);
    float scaled = t * (float)palette_num_colors;
    int idx1 = (int)floorf(scaled);
    float frac = scaled - (float)idx1;

    int n = (int)palette_num_colors;
    idx1 = idx1 % n;
    if (idx1 < 0) idx1 += n;
    int idx2 = (idx1 + 1) % n;

    const uint8_t *c1 = &palette_colors[idx1 * 3];
    const uint8_t *c2 = &palette_colors[idx2 * 3];

    *r = (uint8_t)((float)c1[0] + ((float)c2[0] - (float)c1[0]) * frac);
    *g = (uint8_t)((float)c1[1] + ((float)c2[1] - (float)c1[1]) * frac);
    *b = (uint8_t)((float)c1[2] + ((float)c2[2] - (float)c1[2]) * frac);
}

// HSV to RGB helper
static void hsv_to_rgb(uint8_t h, uint8_t s, uint8_t v, uint8_t *r, uint8_t *g, uint8_t *b)
{
    if (s == 0) {
        *r = *g = *b = v;
        return;
    }
    
    uint8_t region = h / 43;
    uint8_t remainder = (h - (region * 43)) * 6;
    
    uint8_t p = (v * (255 - s)) >> 8;
    uint8_t q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    uint8_t t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    
    switch (region) {
        case 0:  *r = v; *g = t; *b = p; break;
        case 1:  *r = q; *g = v; *b = p; break;
        case 2:  *r = p; *g = v; *b = t; break;
        case 3:  *r = p; *g = q; *b = v; break;
        case 4:  *r = t; *g = p; *b = v; break;
        default: *r = v; *g = p; *b = q; break;
    }
}

void lighting_update(void)
{
    uint32_t now = to_ms_since_boot(get_absolute_time());
    
    // Calculate update interval based on speed (faster speed = shorter interval)
    uint32_t interval = 50 - (effect_speed * 45 / 255);  // 5-50ms
    if (now - last_update_ms < interval) return;
    last_update_ms = now;
    
    // Advance phase
    effect_phase += effect_direction ? -1 : 1;
    
    // Clear LED buffer before rendering - paint overlay will add painted LEDs on top
    memset(led_buffer, 0, sizeof(led_buffer));
    
    switch (current_effect) {
        case LED_EFFECT_STATIC:
            // Restore per-LED colors from static buffer (host-sent colors)
            // Like Shego: copy static_led_buffer -> led_buffer for key LEDs
            for (int logical = 0; logical < KEY_LED_COUNT; logical++) {
                uint8_t physical = led_position_map[logical];
                if (physical < LED_COUNT) {
                    // Read from logical index position in static buffer
                    led_buffer[physical * 3 + 0] = static_led_buffer[logical * 3 + 0];
                    led_buffer[physical * 3 + 1] = static_led_buffer[logical * 3 + 1];
                    led_buffer[physical * 3 + 2] = static_led_buffer[logical * 3 + 2];
                }
            }
            // Also handle ambient LEDs
#if AMBIENT_LED_COUNT > 0
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                uint8_t physical = ambient_led_map[i];
                int logical = KEY_LED_COUNT + i;
                if (physical < LED_COUNT) {
                    led_buffer[physical * 3 + 0] = static_led_buffer[logical * 3 + 0];
                    led_buffer[physical * 3 + 1] = static_led_buffer[logical * 3 + 1];
                    led_buffer[physical * 3 + 2] = static_led_buffer[logical * 3 + 2];
                }
            }
#endif
            break;
            
        case LED_EFFECT_BREATHING: {
            // Breathing between color2 and color1.
            // Use an integer triangle wave to avoid any dependency on libm/trig
            // behaviour across toolchains.
            uint8_t t = (uint8_t)(effect_phase & 0xFF);
            uint8_t breath = (t < 128) ? (uint8_t)(t * 2) : (uint8_t)((255 - t) * 2);
            uint8_t inv = (uint8_t)(255u - breath);
            uint8_t r = (uint8_t)((((uint16_t)color2_r * (uint16_t)inv) + ((uint16_t)color1_r * (uint16_t)breath)) / 255u);
            uint8_t g = (uint8_t)((((uint16_t)color2_g * (uint16_t)inv) + ((uint16_t)color1_g * (uint16_t)breath)) / 255u);
            uint8_t b = (uint8_t)((((uint16_t)color2_b * (uint16_t)inv) + ((uint16_t)color1_b * (uint16_t)breath)) / 255u);
            // Apply to all key LEDs
            for (int i = 0; i < KEY_LED_COUNT; i++) {
                set_key_logical_rgb(i, r, g, b);
            }
            // Apply to ambient LEDs too
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                set_ambient_idx_rgb(i, r, g, b);
            }
            break;
        }
            
        case LED_EFFECT_WAVE:
        case LED_EFFECT_WAVE_REVERSE: {
            // Wave effect - gradient flows across keyboard using orientation (like Shego)
            bool base_reverse = (current_effect == LED_EFFECT_WAVE_REVERSE);
            bool forward = (effect_direction == 0);
            if (base_reverse) forward = !forward;

            float phase = (float)effect_phase * 0.01f;
            
            // Key LEDs: use gradient_base_t for proper orientation handling
            for (int i = 0; i < KEY_LED_COUNT; i++) {
                float x, y;
                mina_taki_logical_xy(i, &x, &y);
                float base_t = gradient_base_t(x, y);  // Respects orientation setting
                float t = forward ? (base_t + phase) : (base_t - phase);
                uint8_t r, g, b;
                gradient_sample_cyclic_palette(t, gradient_colors, gradient_num_colors, &r, &g, &b);
                set_key_logical_rgb(i, r, g, b);
            }
            // Ambient LEDs: use linear position along strip
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                float pos = (AMBIENT_LED_COUNT <= 1) ? 0.5f : ((float)i / (float)(AMBIENT_LED_COUNT - 1));
                float t = forward ? (pos + phase) : (pos - phase);
                uint8_t r, g, b;
                gradient_sample_cyclic_palette(t, gradient_colors, gradient_num_colors, &r, &g, &b);
                set_ambient_idx_rgb(i, r, g, b);
            }
            break;
        }
            
        case LED_EFFECT_RADIAL: {
            // Radial wave from center outward
            bool forward = (effect_direction == 0);
            float phase = (float)effect_phase * 0.02f;
            
            // Key LEDs: use distance from center (0.5, 0.5)
            for (int i = 0; i < KEY_LED_COUNT; i++) {
                float x, y;
                mina_taki_logical_xy(i, &x, &y);
                float dx = x - 0.5f;
                float dy = y - 0.5f;
                float dist = sqrtf(dx*dx + dy*dy) * 1.414f;  // Normalize to ~0..1
                float t = forward ? (dist + phase) : (dist - phase);
                uint8_t r, g, b;
                gradient_sample_cyclic_palette(t, gradient_colors, gradient_num_colors, &r, &g, &b);
                set_key_logical_rgb(i, r, g, b);
            }
            // Ambient LEDs: use linear position
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                float pos = (AMBIENT_LED_COUNT <= 1) ? 0.0f : fabsf(((float)i / (float)(AMBIENT_LED_COUNT - 1)) - 0.5f) * 2.0f;
                float t = forward ? (pos + phase) : (pos - phase);
                uint8_t r, g, b;
                gradient_sample_cyclic_palette(t, gradient_colors, gradient_num_colors, &r, &g, &b);
                set_ambient_idx_rgb(i, r, g, b);
            }
            break;
        }
            
        case LED_EFFECT_GRADIENT: {
            // Static gradient based on key position (uses orientation like Shego)
            for (int i = 0; i < KEY_LED_COUNT; i++) {
                float x, y;
                mina_taki_logical_xy(i, &x, &y);
                // Use gradient_base_t which respects orientation setting
                float pos = gradient_base_t(x, y);
                float scaled = pos * (gradient_num_colors - 1);
                int idx1 = (int)scaled;
                int idx2 = idx1 + 1;
                if (idx2 >= gradient_num_colors) idx2 = gradient_num_colors - 1;
                float frac = scaled - idx1;
                
                uint8_t r1 = gradient_colors[idx1 * 3];
                uint8_t g1 = gradient_colors[idx1 * 3 + 1];
                uint8_t b1 = gradient_colors[idx1 * 3 + 2];
                uint8_t r2 = gradient_colors[idx2 * 3];
                uint8_t g2 = gradient_colors[idx2 * 3 + 1];
                uint8_t b2 = gradient_colors[idx2 * 3 + 2];
                
                uint8_t r = r1 + (uint8_t)((float)(r2 - r1) * frac);
                uint8_t g = g1 + (uint8_t)((float)(g2 - g1) * frac);
                uint8_t b = b1 + (uint8_t)((float)(b2 - b1) * frac);
                set_key_logical_rgb(i, r, g, b);
            }
            // Ambient: gradient along strip
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                float pos = (AMBIENT_LED_COUNT <= 1) ? 0.5f : ((float)i / (float)(AMBIENT_LED_COUNT - 1));
                float scaled = pos * (gradient_num_colors - 1);
                int idx1 = (int)scaled;
                int idx2 = idx1 + 1;
                if (idx2 >= gradient_num_colors) idx2 = gradient_num_colors - 1;
                float frac = scaled - idx1;
                
                uint8_t r1 = gradient_colors[idx1 * 3];
                uint8_t g1 = gradient_colors[idx1 * 3 + 1];
                uint8_t b1 = gradient_colors[idx1 * 3 + 2];
                uint8_t r2 = gradient_colors[idx2 * 3];
                uint8_t g2 = gradient_colors[idx2 * 3 + 1];
                uint8_t b2 = gradient_colors[idx2 * 3 + 2];
                
                uint8_t r = r1 + (uint8_t)((float)(r2 - r1) * frac);
                uint8_t g = g1 + (uint8_t)((float)(g2 - g1) * frac);
                uint8_t b = b1 + (uint8_t)((float)(b2 - b1) * frac);
                set_ambient_idx_rgb(i, r, g, b);
            }
            break;
        }
            
        case LED_EFFECT_RAINBOW: {
            // Rainbow based on key position
            for (int i = 0; i < KEY_LED_COUNT; i++) {
                float x, y;
                mina_taki_logical_xy(i, &x, &y);
                // Use X + Y for diagonal rainbow
                uint8_t hue = (uint8_t)(((int)((x + y) * 128) + effect_phase) % 256);
                uint8_t r, g, b;
                hsv_to_rgb(hue, 255, 255, &r, &g, &b);
                set_key_logical_rgb(i, r, g, b);
            }
            // Ambient: rainbow along strip
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                float pos = (AMBIENT_LED_COUNT <= 1) ? 0.5f : ((float)i / (float)(AMBIENT_LED_COUNT - 1));
                uint8_t hue = (uint8_t)(((int)(pos * 256) + effect_phase) % 256);
                uint8_t r, g, b;
                hsv_to_rgb(hue, 255, 255, &r, &g, &b);
                set_ambient_idx_rgb(i, r, g, b);
            }
            break;
        }
            
        case LED_EFFECT_REACTIVE: {
            // Keys light up when pressed, then fade
            // Decay reactive keys
            for (int i = 0; i < SENSOR_COUNT; i++) {
                if (reactive_keys[i] > 0) {
                    reactive_keys[i] = (reactive_keys[i] > 8) ? reactive_keys[i] - 8 : 0;
                }
            }
            
            // Apply reactive colors to key LEDs
            for (int i = 0; i < KEY_LED_COUNT && i < SENSOR_COUNT; i++) {
                uint8_t brightness = reactive_keys[i];
                uint8_t r = (color1_r * brightness) / 255;
                uint8_t g = (color1_g * brightness) / 255;
                uint8_t b = (color1_b * brightness) / 255;
                set_key_logical_rgb(i, r, g, b);
            }
            // Ambient stays off for reactive
            break;
        }
            
        default:
            break;
    }

    // Overlay SignalRGB streaming data on enabled zones.
    // SignalRGB sends data in logical order, so we need to map it
    if (signalrgb_valid && (streaming_zones_mask & 0x03)) {
        // Zone 0: main keys
        if (streaming_zones_mask & 0x01) {
            for (int i = 0; i < KEY_LED_COUNT && i < SENSOR_COUNT; i++) {
                set_key_logical_rgb(i, 
                    signalrgb_buffer[i * 3 + 0],
                    signalrgb_buffer[i * 3 + 1],
                    signalrgb_buffer[i * 3 + 2]);
            }
        }
        // Zone 1: ambient strip
        if ((streaming_zones_mask & 0x02) && AMBIENT_LED_COUNT > 0) {
            for (int i = 0; i < AMBIENT_LED_COUNT; i++) {
                int src_idx = SENSOR_COUNT + i;
                if (src_idx < LED_COUNT) {
                    set_ambient_idx_rgb(i,
                        signalrgb_buffer[src_idx * 3 + 0],
                        signalrgb_buffer[src_idx * 3 + 1],
                        signalrgb_buffer[src_idx * 3 + 2]);
                }
            }
        }
    }

    output_leds();
}

// ========================================
// GETTERS FOR FLASH STORAGE
// ========================================
void lighting_get_led_buffer(uint8_t *buffer, uint16_t len) {
    if (buffer && len >= sizeof(led_buffer)) {
        memcpy(buffer, led_buffer, sizeof(led_buffer));
    }
}

uint8_t lighting_get_brightness(void) {
    return (uint8_t)(g_brightness_scale * 100.0f);
}

uint8_t lighting_get_effect(void) {
    return (uint8_t)current_effect;
}

uint8_t lighting_get_effect_speed(void) {
    return effect_speed;
}

uint8_t lighting_get_effect_direction(void) {
    return effect_direction;
}

void lighting_get_effect_color1(uint8_t *r, uint8_t *g, uint8_t *b) {
    if (r) *r = color1_r;
    if (g) *g = color1_g;
    if (b) *b = color1_b;
}

void lighting_get_effect_color2(uint8_t *r, uint8_t *g, uint8_t *b) {
    if (r) *r = color2_r;
    if (g) *g = color2_g;
    if (b) *b = color2_b;
}

void lighting_set_caps_lock_overlay(bool enabled, bool active) {
    caps_overlay_enabled = enabled;
    caps_overlay_active = active;
}

void lighting_set_caps_lock_color(uint8_t r, uint8_t g, uint8_t b) {
    caps_color_r = r;
    caps_color_g = g;
    caps_color_b = b;
}

// Layer indicator functions
void lighting_set_layer_color(uint8_t layer, uint8_t r, uint8_t g, uint8_t b) {
    if (layer == 0) return;  // Layer 0 never has an indicator
    if (layer < 4) {
        layer_colors[layer][0] = r;
        layer_colors[layer][1] = g;
        layer_colors[layer][2] = b;
    }
}

void lighting_get_layer_color(uint8_t layer, uint8_t *r, uint8_t *g, uint8_t *b) {
    if (layer < 4) {
        if (r) *r = layer_colors[layer][0];
        if (g) *g = layer_colors[layer][1];
        if (b) *b = layer_colors[layer][2];
    } else {
        if (r) *r = 0;
        if (g) *g = 0;
        if (b) *b = 0;
    }
}

void lighting_set_active_layer(uint8_t layer) {
    current_layer_for_indicator = layer < 4 ? layer : 0;
    if (layer == 0) {
        layer_indicator_forced = false;
        return;
    }
    bool has_color = layer < 4 && (layer_colors[layer][0] > 0 || layer_colors[layer][1] > 0 || layer_colors[layer][2] > 0);
    layer_indicator_forced = has_color;
}

uint8_t lighting_get_active_layer(void) {
    return current_layer_for_indicator;
}

void lighting_socd_animation(bool enabled) {
#if AMBIENT_LED_COUNT > 0
    socd_anim_active = true;
    socd_anim_green = enabled;
    socd_anim_step = 0;
    socd_anim_fade = 255;
    socd_anim_last_ms = to_ms_since_boot(get_absolute_time());
#else
    (void)enabled;
#endif
}
